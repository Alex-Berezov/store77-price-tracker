name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ==========================================
  # Build and Push Docker Images
  # ==========================================
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      web-image: ${{ steps.meta-web.outputs.tags }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version
        id: version
        run: |
          VERSION=$(date +'%Y%m%d')-$(echo ${{ github.sha }} | cut -c1-7)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      # ----------------------------------------
      # API Image
      # ----------------------------------------
      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api
          tags: |
            type=raw,value=${{ steps.version.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix=

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/api/Dockerfile
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production

      # ----------------------------------------
      # Web Image
      # ----------------------------------------
      - name: Extract metadata for Web
        id: meta-web
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web
          tags: |
            type=raw,value=${{ steps.version.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix=

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: ${{ steps.meta-web.outputs.tags }}
          labels: ${{ steps.meta-web.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            NEXT_PUBLIC_API_URL=${{ vars.API_URL || 'http://localhost:8080' }}

  # ==========================================
  # Deploy to Server via SSH
  # ==========================================
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build-and-push
    # Only run if SSH secrets are configured
    if: ${{ secrets.SSH_PRIVATE_KEY != '' }}
    environment:
      name: production
      url: ${{ vars.APP_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p ~/store77-price-tracker"

      - name: Copy docker-compose file
        run: |
          scp docker-compose.prod.yml ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/store77-price-tracker/docker-compose.yml

      - name: Create .env file on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cat > ~/store77-price-tracker/.env << 'ENVFILE'
          # Database
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_HOST=postgres
          DB_PORT=5432
          DATABASE_URL=postgresql://${{ secrets.DB_USER }}:${{ secrets.DB_PASSWORD }}@postgres:5432/${{ secrets.DB_NAME }}?schema=public

          # Redis
          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}

          # API
          API_PORT=8080
          API_HOST=0.0.0.0
          NODE_ENV=production

          # Docker images
          API_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ needs.build-and-push.outputs.version }}
          WEB_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:${{ needs.build-and-push.outputs.version }}
          ENVFILE
          EOF

      - name: Login to Container Registry on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "echo ${{ secrets.GITHUB_TOKEN }} | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin"

      - name: Pull and deploy containers
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/store77-price-tracker

          # Pull latest images
          docker-compose pull

          # Stop existing containers gracefully
          docker-compose down --timeout 30

          # Start new containers
          docker-compose up -d

          # Wait for containers to be healthy
          echo "Waiting for services to be healthy..."
          sleep 10

          # Run database migrations
          docker-compose exec -T api npx prisma migrate deploy

          # Show container status
          docker-compose ps
          EOF

      - name: Cleanup old images
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "docker image prune -af --filter 'until=24h'"

  # ==========================================
  # Health Check
  # ==========================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy
    # Only run if deploy job ran (not skipped)
    if: ${{ needs.deploy.result == 'success' }}

    steps:
      - name: Wait for services to stabilize
        run: sleep 30

      - name: Check API health
        run: |
          echo "Checking API health..."
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" ${{ vars.API_URL }}/health || echo "000")
            if [ "$response" = "200" ]; then
              echo "âœ… API is healthy (HTTP $response)"
              exit 0
            fi
            echo "Attempt $i: API returned HTTP $response, waiting..."
            sleep 10
          done
          echo "âŒ API health check failed after 5 attempts"
          exit 1

      - name: Check Web health
        run: |
          echo "Checking Web health..."
          for i in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" ${{ vars.APP_URL }} || echo "000")
            if [ "$response" = "200" ]; then
              echo "âœ… Web is healthy (HTTP $response)"
              exit 0
            fi
            echo "Attempt $i: Web returned HTTP $response, waiting..."
            sleep 10
          done
          echo "âŒ Web health check failed after 5 attempts"
          exit 1

      - name: Verify API endpoints
        run: |
          echo "Verifying API endpoints..."

          # Check currency rate endpoint
          curl -sf ${{ vars.API_URL }}/api/currency/rate > /dev/null && \
            echo "âœ… Currency rate endpoint OK" || \
            echo "âš ï¸ Currency rate endpoint not available"

          # Check products endpoint
          curl -sf ${{ vars.API_URL }}/api/products?limit=1 > /dev/null && \
            echo "âœ… Products endpoint OK" || \
            echo "âš ï¸ Products endpoint not available"

          # Check categories endpoint
          curl -sf ${{ vars.API_URL }}/api/categories > /dev/null && \
            echo "âœ… Categories endpoint OK" || \
            echo "âš ï¸ Categories endpoint not available"

  # ==========================================
  # Notify on Failure
  # ==========================================
  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy, health-check]
    if: ${{ always() && (needs.build-and-push.result == 'failure' || needs.deploy.result == 'failure' || needs.health-check.result == 'failure') }}

    steps:
      - name: Create failure summary
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details." >> $GITHUB_STEP_SUMMARY

  # ==========================================
  # Notify on Success
  # ==========================================
  notify-success:
    name: Notify on Success
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy, health-check]
    if: ${{ always() && needs.build-and-push.result == 'success' && (needs.deploy.result == 'success' || needs.deploy.result == 'skipped') }}

    steps:
      - name: Create success summary
        run: |
          echo "## âœ… Build Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.build-and-push.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Docker Images" >> $GITHUB_STEP_SUMMARY
          echo "- API: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ needs.build-and-push.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Web: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:${{ needs.build-and-push.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "### âš ï¸ Deploy Skipped" >> $GITHUB_STEP_SUMMARY
            echo "SSH secrets not configured. Configure secrets to enable auto-deploy." >> $GITHUB_STEP_SUMMARY
          else
            echo "### URLs" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ App: ${{ vars.APP_URL }}" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“š API Docs: ${{ vars.API_URL }}/api/docs" >> $GITHUB_STEP_SUMMARY
          fi
